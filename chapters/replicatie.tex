\documentclass[../samenvatting.tex]{subfiles}
\begin{document}

\chapter{Replicatie}
Replicatie, het bijhouden van meerdere equivalente kopiën op verschillende servers, vergroot performantie, availability(ook tijdens disconnected working) en fout-tolerantie. Caching is een beperkte vorm van replicatie. Meestal wordt er replication transparency vereist, zodat de clients maar één kopie zien en niet meerdere. Ook moet de data consistent blijven, zodat een verandering overal te zien is.

Bij het opstellen van een goed replicatie-model gaan we er meestal enkel vanuit dat servers enkel falen door crashing. We gaan er ook vanuit dat operaties op een gerepliceerd object deterministisch zijn en een operatie ondeelbaar is. 

De vijf fasen die de performance van een request bepalen zijn de request (wordt de request door één replica-manager ontvangen of door een multicast aan allen gestuurd), de coordinatie(wordt de request uitgevoerd, welke volgorde wordt gebruikt? (volgordes: FIFO, causale ordering, totale ordering)), de uitvoering van een request (eventueel tentatief), de agreement (consensus op het effect van een request) en de response (één of meerdere replica-managers responden, front-end bepaalt wanneer een request succesvol is).

De meest stricte vorm voor correctness van gerepliceerde data is lineairiseerbaarheid, waar er minstens één sequentie moet zijn zodat een sequentie van operaties hetzelfde moet werken als ware er slechts één kopie van de objecten en de volgorde consistent is met de echte volgorde.

Een zwakkere vorm is sequentiele consistentie, waarbij er minstens één sequentie moet zijn zodat er een enkele correcte kopie is en de volgorde consistent is met de programma volgorde van elke individuele client. Dit is te vergelijken met het schudden van meerdere pakken kaarten, waarbij ieder pak kaarten zijn originele volgorde behoudt (enkel de pakjes van de kaarten, de kaarten zelf blijven in de juiste volgorde).

In een passief(primary-backup) replicatie systeem, is er één primaire replica-manager en meerdere backups. De front-end stuurt de request naar de primaire replica-manager, die de request behandelt, uitvoert, alle backups de nieuwe staat, de response en de identifier doorstuurt. De backups sturen een acknowledgement, waarna de primaire replica-manager een response terugstuurt naar de front-end. Als de primary faalt, maar vervangen wordt door één unieke backup als primary EN alle replica-managers het eens zijn over welke operaties wel en niet zijn uitgevoerd, kan het systeem zonder problemen verder werken. Eventueel kunnen read-requests direct naar backups worden gestuurd, om performance te verbeteren.

Bij een actief replicatie systeem spelen alle replica-managers een equivalente rol. De front-ent multicast een request naar alle replica-managers die allemaal antwoorden. Alle replica-managers voeren de request precies hetzelfde uit. De front-end bepaalt bij hoeveel responses (één of minstens $n$) er een antwoord naar de client wordt gestuurd. Een dergelijk systeem heeft sequentiele consistentie.

Een gossip architectuur is gebaseerd op het uitwisselen van 'gossip'-berichten. Dit heeft een zwakkere consistentie, waar clients soms merken dat er gebruik gemaakt wordt van replica's. De front-end contacteert één replica-manager tegelijk, maar kan wel een andere contacteren als de ene druk of onbereikbaar is. Een query-operatie is blocking totdat er een resultaat is, een update operatie is non-blocking. De replica-manager antwoordt de client zodra hij de update ontvangen heeft. De request wordt pas behandeld als deze volgens de ordering constraints mag behandeld worden, eventueel na het onvangen van updates van andere replica-managers. Als de request een query is, stuurt de replica-manager een antwoord naar de client. Met behulp van gosip messages worden de andere servers op de hoogte gesteld van updates in een lazy fashion (meerdere updates in één keer, of op request van een andere replica-manager).

Bayou zorgt voor high availability, maar lagere consistentie dan sequentiele consistentie. Updates worden gestuurd in pairs, met een anti-entropy protocol. Hier wordt een domein-specifieke conflict-resolver gebruikt. Hier wordt een operationele transformatie gedaan. Updates zijn eerst tentatief, en worden later gecommit. Er wordt één primaire replica-manager gekozen die de committed order bepaalt en de updates doorstuurt naar andere replica-managers. Iedere update heeft een dependency check en een merge procedure (domein specifiek). Voor een operatie uitgevoerd wordt, wordt de dependency check uitgevoerd en als deze faalt de merge procedure. 

Het Coda file systeem is gebaseerd op AFS maar biedt hoge availability ondanks gedisconnecte operatie. Het doel is constante data toegankelijkheid. Coda draait Venus op de client en Vice op de servers. Beide zijn replica-managers. De Available Volume Storage Group bestaat uit de server replica-managers die bereikbaar zijn vanuit Venus. Kopiën op de server zijn more reliable dan die in de cache. Iedere file heeft een Coda version vector (CVV) die bijhoudt hoeveel wijzigingen er gedaan zijn (en bij welke servers). Bij iedere update wordt de versie verhoogd. Als één van de CVV's groter is dan alle andere, is er geen conflict en worden oudere replica's automatisch up-to-date gebracht. Als er twee verschillende CVV's groter zijn dan de rest, is er een conflict. In dat geval moet de gebruiker het conflict handmatig oplossen. Als een veranderd bestand wordt gesloten, wordt iedere replica-manager in de AVSG de update gestuurd, inclusief de nieuwe CVV. Clients zijn zo veel mogelijk verantwoordelijk voor het doorsturen van updates, die ze enkel naar hun AVSG kunnen doorsturen. De callback promise wordt door maar één server bijgehouden. Venus stuurt probes naar alle servers in de VSG, iedere T seconden. Van bereikbare servers wordt een volume version vector gestuurd (een samenvatting van alle CVV's). Coda geeft de mogelijkheid om handmatig aan te geven welke files in de cache behouden moeten worden (sticky). 

\end{document}