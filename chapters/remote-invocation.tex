\documentclass[../samenvatting.tex]{subfiles}
\begin{document}

\chapter{Remote Invocation}

Request-reply protocols bouwen op basis van standaard message passing een two-way communicatie.  Ack's zijn niet nodig, omdat requests altijd gevolgd worden door replies. \texttt{doOperation} is de client-operatie die een operatie marshallt en naar de server stuurt. Daarna stuurt deze methode een receive om een antwoord te ontvangen. De server heeft een \texttt{getRequest} methode die een request aanvaardt waarna de methode wordt uitgevoerd en het resultaat met \texttt{sendReply} wordt teruggestuurd. De client ontvangt de reply met \texttt{receive} en geeft het resultaat terug aan de caller van de methode. Een message bevat een message identifier(bestaande uit een requestID voor de sender en een IP/poort voor de receiver). \texttt{doOperation} gebruikt timeouts om fouten bij het verzenden/ontvangen van requests te herkennnen. Na een timeout wordt er nogmaals geprobeerd totdat er zeker geen antwoord meer komt van de server. De server gebruikt het requestID om te bepalen of een request nieuw is of een duplicaat. Het resultaat van een operatie moet worden bijgehouden of operaties moeten idempotent zijn om lost reply messages op te lossen. Er zijn drie soorten protocols: Request, Request-Reply, Request-Reply-Acknowledge. Met behulp van TCP is Request-Reply gemakkelijk te implementeren. 

De Remote Procedure Calls laat programma's toe transparant remote procedures aan te roepen. Hierbij moet rekening gehouden worden met input- en outputvariabelen (C), met references (call by reference werkt niet in een gedistribueerd systeem). Interface Definition Languages zijn gemaakt om procedures geimplementeerd in de ene taal ook te laten aanroepen door een andere taal. Vaak wordt er een verschil in de interface gemaakt om aan te geven dat een procedure een RPC is, omdat deze vaak veel meer latency hebben. Iedere procedure heeft een locale stub die de request naar de echte procedure doorstuut.

De Remote Method Invocation laat toe om methodes op objecten uit te voeren, met remote objecten. Hierbij blijft een objectgeorienteerde approach mogelijk en kunnen objecten ook een parameter zijn voor methodes. Exceptions worden gebruikt als een gemakkelijke manier voor het detecteren en dealen met fouten. Objecten geven de mogelijkheid (en verplichting) tot encapsulatie. Ook geven ze de mogelijkheid tot replicatie, waardoor objecten als parameter meegegeven kunnen worden en er methodes op opgeroepen kunnen worden. Remote objects zijn objecten waar remote methodes op kunnen worden aangeroepen. Deze hebben een remote interface, die aangeven welke methodes remote aangeroepen kunnen worden. Een RMI-systeem moet distributed garbage collection aanbieden als de locale versie dat heeft. Hierbij moet er samengewerkt op basis van lokale garbage collection. De Remote Reference module zorgt voor de vertaling van lokale objecten naar remote objecten, zodat requests en replies van en naar de juiste objecten gaan. Servants zijn instanties van een Remote class en behandelen de remote methods uiteindelijk. De RMI software voorziet een proxy (stub) voor remote objecten, een dispatcher op de server die na de request de aanvraag doorstuurt naar het skeleton en een skeleton (krijgt de aanvragen direct binnen van de dispatcher en stuurt ze door naar de servant). Remote objecten kunnen niet aangemaakt worden met een standaard constructor (door de client), dus moet een factory gebruikt worden. Een binder (registry) houdt referenties naar remote objecten bij. Objecten kunnen passief opgeslagen worden om resources niet onnodig te verspillen. Persistene object storages kunnen objecten permanent passief opslaan en actief maken indien nodig. Met behulp van leases kunnen objecten die door garbage collection niet verwijderd zijn, alsnog verwijderd worden. Als de lease verlopen is, zal de connectie verwijderd worden.
\end{document}